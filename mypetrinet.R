## Sourced from petRi.R
######################################################################
# Author: Michael HË†hle <hoehle@stat.uni-muenchen.de>
# Date:   11 July 2004
#
# Petri nets in R. A small reader and player for 
# ordinary petri nets generated by CPN Tools (wiki.daimi.au.dk/cpntools).
# In R the Petri  Net can be annotated with simple
# stochastic petri net features.
#
# License:
#  GPL (see license.txt)
#
# Requirements:
#  XML Package (http://www.omegahat.org/RSXML/)
#  msm Package
#
# Comments:
#  To find a Windows binary of the XML Package use
#  http://www.stats.ox.ac.uk/pub/RWin
#
# Features:
#  * animated token game
#  * simulation to log file
#  * generalized stochastic petri nets by defining delay function distribution
#    this can be state dependent etc.
#
# Known bugs:
#  - fancy arrow drawing with curves is ignored.
#  - colored petri nets not supported. All types have to be INT
#    and only supported type is 1, i.e 12`1 works.
#
# ToDo:
#  - R Package
######################################################################

petrinet <- function(name, places_df, trans_df, arcs_df) {
    # (mostly) duplicated code in add.petrinet
    #   refactor code if it needs to be changed 

    trans <- trans_df[, c("id","name","x","y")]
    places <- places_df[, c("id","name","x","y","M0")]

    #No of places
    p <- nrow(places)
    #No of transitions
    t <- nrow(trans)

    #A p \times t matrix.
    Cin <- matrix(0,t,p)
    Cout <- matrix(0,t,p)

    #Attach correct names to C'tables
    dimnames(Cin) <- list(trans$name,places$name)
    dimnames(Cout) <- list(trans$name,places$name)

    for (row in (1:nrow(arcs_df))) {
        t_out <- match(arcs_df[row, "begin"], trans$name)
        t_in  <- match(arcs_df[row, "end"],   trans$name)
        p_out <- match(arcs_df[row, "begin"], places$name)
        p_in  <- match(arcs_df[row, "end"],   places$name)
        if ((is.na(t_in) & is.na(p_in)) |
            (is.na(t_out) & is.na(p_out))) {
            stop("arc: ", arcs_df[row, ], ": this should not happen")
        }    

        if (!is.na(t_in) & !is.na(p_out)) {
            Cin [t_in,  p_out] <- Cin [t_in,  p_out]  + 1
        } else if (!is.na(t_out) & !is.na(p_in)) {
            Cout[t_out, p_in ] <- Cout[t_out, p_in ] + 1
        } else stop("this should not happen")

    }

    #Update Matrix (i.e. token transition)
    C <- Cout - Cin

    ##Use initital marking from CPN File and give names.
    M <- places$M0

    #Initial time
    time <- 0

    #Define petri net object using a list construct.
    pn <- list( name=name, trans=trans, places=places,
                Cin=Cin,Cout=Cout,C=C,
                p=p,t=t,M0=M,M=M,time=time)

    class(pn) <- "petrinet"
    #print(pn)
    return(pn)
}

add.petrinet <- function(pn, places_df=data.frame(), arcs_df=data.frame()) {
    # (mostly) duplicated code in petrinet
    #   refactor code if it needs to be changed 

    # Reset the petrinet first
    pn$M <- pn$M0; pn$time = 0

    if(nrow(places_df) > 0) {
        pn$places <- rbind(pn$places, cbind(
            data.frame(id=(nrow(pn$places)+1):(nrow(pn$places)+nrow(places_df))),
                                            places_df))
        #Update arc matrices
        pn$Cin <- cbind(pn$Cin, matrix(rep(0, nrow(pn$Cin)*nrow(places_df)),
                                       nrow=nrow(pn$Cin),
                                dimnames=list(rownames(pn$Cin), places_df$name)))
        pn$Cout <- cbind(pn$Cout, matrix(rep(0, nrow(pn$Cout)*nrow(places_df)),
                                       nrow=nrow(pn$Cout),
                                dimnames=list(rownames(pn$Cout), places_df$name)))
        pn$C <- cbind(pn$C, matrix(rep(0, nrow(pn$C)*nrow(places_df)),
                                       nrow=nrow(pn$C),
                                    dimnames=list(rownames(pn$C), places_df$name)))

        pn$p <- pn$p + nrow(places_df)
        pn$M <- pn$M0 <- c(pn$M0, places_df$M0)
    }

    if(nrow(arcs_df) > 0) {
        for (row in (1:nrow(arcs_df))) {
            t_out <- match(arcs_df[row, "begin"], pn$trans$name)
            t_in  <- match(arcs_df[row, "end"],   pn$trans$name)
            p_out <- match(arcs_df[row, "begin"], pn$places$name)
            p_in  <- match(arcs_df[row, "end"],   pn$places$name)
            if ((is.na(t_in) & is.na(p_in)) |
                    (is.na(t_out) & is.na(p_out))) {
                stop("arc: ", arcs_df[row, ], ": this should not happen")
            }

            if (!is.na(t_in) & !is.na(p_out)) {
                pn$Cin [t_in,  p_out] <- pn$Cin [t_in,  p_out]  + 1
            } else if (!is.na(t_out) & !is.na(p_in)) {
                pn$Cout[t_out, p_in ] <- pn$Cout[t_out, p_in ] + 1
            } else stop("this should not happen")

        }

        #Update Matrix (i.e. token transition)
        pn$C <- pn$Cout - pn$Cin
    }

    return(pn)
}

###################################################################
# Generate a list of length equal to the no of transitions indicating
# for each whether it is enabled at the current marking or not.
###################################################################
enabled.transitions <- function(pn) {
    #Repeat Marking for each transition
    Mrep <- matrix(rep(pn$M,pn$t),pn$t,pn$p,byrow=TRUE)
    #Check that M>=Cin
    return(apply( Mrep >= pn$Cin,MARGIN=1,prod))
}

######################################################################
# Plot a Petri net with initial marking.
#
# Params:
#  pn - the petri net to draw
#  draw.enabled - boolean, all enabled transitions are shown as green
######################################################################

plot.petrinet <- function(x,...) {
    #Hack stuff to get from S3 representation to a more readable thing.
    pn <- x
    opts <- list(...)
    #Draw places and transitions
    rx <- range(pn$places$x,pn$trans$x)
    ry <- range(pn$places$y,pn$trans$y)
    xlim = rx + c(-1,1)*diff(rx)/10
    ylim = ry + c(-1,1)*diff(ry)/10
    dx <- diff(xlim)*1/15
    dy <- diff(ylim)*1/25
    #Different radia
    r1 <- 4/5*dx
    r2 <- 4/5*dy
    r3  <- dx/3
    #Draw places and transitions.
    #if ((xlim[2] - xlim[1]) > 100) cex <- 7 else cex <- 10
    cex <- 10
    plot(pn$places$x,pn$places$y,cex=cex,xlim=xlim,ylim=ylim,axes=FALSE,xlab="",ylab="")
    rect(pn$trans$x-dx,pn$trans$y-dy,pn$trans$x+dx,pn$trans$y+dy)

    ######################################################################
    #Draw arrows by looping over all trans x places pairs.
    ######################################################################
    for (t in 1:nrow(pn$trans)) {
        for (p in 1:nrow(pn$places)) {
            #In arrows: place -> transition
            if (pn$Cin[t,p]>0) {
                #Show enabled transitions - if so then in green (col=3)?
                #col <- opts$draw.enabled * enabled.transitions(pn)[t]*2+1
                if ((pn$places$y[p] - pn$trans$y[t]) > 0) {
                    beg_dy <- 0 - dy; end_dy <- dy
                } else if ((pn$places$y[p] - pn$trans$y[t]) < 0) {
                    beg_dy <- dy; end_dy <- 0 - dy
                } else {
                    beg_dy <- 0; end_dy <- 0
                }
                if ((pn$places$x[p] - pn$trans$x[t]) > 0) {
                    beg_dx <- 0 - dx; end_dx <- dx
                } else if ((pn$places$x[p] - pn$trans$x[t]) < 0) {
                    beg_dx <- dx; end_dx <- 0 - dx
                } else {
                    beg_dx <- 0; end_dx <- 0
                }


                if (enabled.transitions(pn)[t] > 0)
                    arrows(pn$places$x[p]+beg_dx,pn$places$y[p]+2.5*beg_dy,
                           pn$trans$x[t]+0.5*end_dx,pn$trans$y[t]+end_dy,
                           lwd=2, col="green")
                else
                    arrows(pn$places$x[p]+beg_dx,pn$places$y[p]+2.5*beg_dy,
                           pn$trans$x[t]+0.5*end_dx,pn$trans$y[t]+end_dy,
                           lwd=2)
            }
            #Out arrows, i.e. transition -> place
            if (pn$Cout[t,p]>0) {
                if ((pn$places$y[p] - pn$trans$y[t]) < 0) {
                    beg_dy <- 0 - dy; end_dy <- dy
                } else if ((pn$places$y[p] - pn$trans$y[t]) > 0) {
                    beg_dy <- dy; end_dy <- 0 - dy
                } else  {
                    beg_dy <- 0; end_dy <- 0
                }
                if ((pn$places$x[p] - pn$trans$x[t]) < 0) {
                    beg_dx <- 0 - dx; end_dx <- dx
                } else if ((pn$places$x[p] - pn$trans$x[t]) > 0) {
                    beg_dx <- dx; end_dx <- 0 - dx
                } else  {
                    beg_dx <- 0; end_dx <- 0
                }

                arrows(pn$trans$x[t]+0.5*beg_dx,pn$trans$y[t]+beg_dy,
                       pn$places$x[p]+0.5*end_dx,pn$places$y[p]+2.5*end_dy,
                       lwd=2)
            }

            #show weight if greater than one
            cx <- (pn$places$x[p] + pn$trans$x[t])/2
            cy <- (pn$places$y[p] + pn$trans$y[t])/2
            if (pn$Cin[t,p]>1 )  { text(cx,cy,pn$Cin[t,p],cex=1.5,col=4)}
            if (pn$Cout[t,p]>1)  { text(cx,cy,pn$Cout[t,p],cex=1.5,col=4)}

        }
    }

    ######################################################################
    #Draw names
    ######################################################################
    text(pn$places$x,pn$places$y-dy,pn$places$name,col=4)
    text(pn$trans$x,pn$trans$y-dy,pn$trans$name)

    ######################################################################
    #Plot markings
    ######################################################################
    for (i in 1:pn$p) {
        mark <- pn$M[i]
        #If the place is marked then show all marks
        #Draw marks so its centered about the place's centre
        if (mark>0) {
            #Center
            cx <- pn$places$x[i]
            cy <- pn$places$y[i]
            #If there is only one mark its put in the center
            if (mark==1) {
                symbols(x=cx,y=cy,circles=dx/3,inches=FALSE,add=TRUE,bg=2)
            } else if (mark<5) {
                #If there are more than one angles and radius to place mark balls on
                angles <- (0:(mark-1))*2*3.141592/mark
                for (m in 1:mark) {
                    symbols(x=cx+r1*cos(angles[m]),y=cy+r2*sin(angles[m]),circles=r3,inches=FALSE,add=TRUE,bg=2)
                }
            } else {
                ##Too much to draw just print the number
                symbols(x=cx,y=cy,circles=2*r3,inches=FALSE,add=TRUE,bg=2)
                text(cx,cy,mark)
            }
        }
    }

    invisible()
}

ggplot.petrinet <- function(pn) {
    require(ggplot2)
    require(grid)

    dx <- 1; dy <- 1
    gp <- ggplot() +
            geom_point(aes_string(x="x", y="y"), shape=1, size=15,
                       data=pn$places) +
            geom_text(aes_string(x="x", y=paste0("y-",0.5*dy), label="name"),
                      data=pn$places, color="blue") +
            geom_point(aes_string(x="x", y="y"), shape=0, size=10,
                       data=pn$trans) +
            geom_text(aes_string(x="x", y=paste0("y-",0.0*dy), label="name"),
                      data=pn$trans, color="blue") +
            theme(axis.ticks=element_blank(),
                     #axis.text=element_blank(),
                    axis.line=element_blank(), axis.title = element_blank())

    ######################################################################
    #Draw arrows by looping over all trans x places pairs.
    ######################################################################

    for (t in  1:nrow(pn$trans)) {
        for (p in 1:nrow(pn$places)) {
            #In arrows: place -> transition
            if (pn$Cin[t,p]>0) {
                if ((pn$places$y[p] - pn$trans$y[t]) > 0) {
                    beg_dy <- 0 - dy; end_dy <- dy
                } else if ((pn$places$y[p] - pn$trans$y[t]) < 0) {
                    beg_dy <- dy; end_dy <- 0 - dy
                } else {
                    beg_dy <- 0; end_dy <- 0
                }
                if ((pn$places$x[p] - pn$trans$x[t]) > 0) {
                    beg_dx <- 0 - dx; end_dx <- dx
                } else if ((pn$places$x[p] - pn$trans$x[t]) < 0) {
                    beg_dx <- dx; end_dx <- 0 - dx
                } else {
                    beg_dx <- 0; end_dx <- 0
                }

                #Show enabled transitions in green
                color <- ifelse((enabled.transitions(pn)[t] > 0), "green",
                                "black")
                gp <- gp + geom_segment(aes_string(
                    x=paste0(pn$places$x[p]+1.2*beg_dx),
                    y=paste0(pn$places$y[p]+0.2*beg_dy),
                    xend=paste0(pn$trans$x[t]+1.0*end_dx),
                    yend=paste0(pn$trans$y[t]+0.25*end_dy)),
                    arrow=arrow(length=unit(0.35, "cm")), col=color)
            }

            #Out arrows, i.e. transition -> place
            if (pn$Cout[t,p]>0) {
                if ((pn$places$y[p] - pn$trans$y[t]) < 0) {
                    beg_dy <- 0 - dy; end_dy <- dy
                } else if ((pn$places$y[p] - pn$trans$y[t]) > 0) {
                    beg_dy <- dy; end_dy <- 0 - dy
                } else  {
                    beg_dy <- 0; end_dy <- 0
                }
                if ((pn$places$x[p] - pn$trans$x[t]) < 0) {
                    beg_dx <- 0 - dx; end_dx <- dx
                } else if ((pn$places$x[p] - pn$trans$x[t]) > 0) {
                    beg_dx <- dx; end_dx <- 0 - dx
                } else  {
                    beg_dx <- 0; end_dx <- 0
                }

                gp <- gp + geom_segment(aes_string(
                    x=paste0(pn$trans$x[t]+0.9*beg_dx),
                    y=paste0(pn$trans$y[t]+0.2*beg_dy),
                    xend=paste0(pn$places$x[p]+0.9*end_dx),
                    yend=paste0(pn$places$y[p]+0.3*end_dy)),
                    arrow=arrow(length=unit(0.35, "cm")), col="black")
            }

            #show weight if greater than one
            cx <- (pn$places$x[p] + pn$trans$x[t])/2
            cy <- (pn$places$y[p] + pn$trans$y[t])/2
            if (pn$Cin[t,p]>1 )
                gp <- gp + geom_text(aes_string(
                    x=paste0(cx),y=paste0(cy),label=paste0(pn$Cin[t,p])),
                                    color="blue")
            if (pn$Cout[t,p]>1)
                gp <- gp + geom_text(aes_string(
                    x=paste0(cx),y=paste0(cy),label=paste0(pn$Cout[t,p])),
                                    color="blue")
        }
    }

    ######################################################################
    #Plot markings
    ######################################################################
    for (i in 1:pn$p) {
        mark <- pn$M[i]
        #If the place is marked then show all marks
        #Draw marks so its centered about the place's centre
        if (mark>0) {
            #Center
            cx <- pn$places$x[i]
            cy <- pn$places$y[i]
            if (mark == 1) {
                gp <- gp + geom_point(aes_string(x=paste0(cx), y=paste0(cy)),
                                      size=2, color="red")
            } else {
                for (m in 1:mark)
                    gp <- gp + geom_point(aes_string(x=paste0(cx), y=paste0(cy)),
                                          size=2, color="red", position="jitter")
            }
        }
    }

    return(gp)
}


######################################################################
# Petri Net simulator. With our without animation.
#
# Params:
#  pn - petri net to work on
#  high.priority.trans - if multiple transitions are enabled, which one
#       is a high priority; if this is not one of the enabled transitions
#       then a random enabled transition is fired
#  steps - number of steps to simulate
#  animate - play the token game and show the graphics
#  reset - start with M0 or continue on current marking
#  wait - waiting time to next move * timestep
#  file - logfile , default is stdout.
######################################################################
token.game <- function(pn, high.priority.trans=NULL, steps=1e99,
                           animate=TRUE,reset=FALSE,
                           wait=1000000,file="") {
    #The rewind option goes back to the initial marking.
    if (reset) {pn$M <- pn$M0; pn$time = 0}

    #Find the set of enabled transitions.
    isenabled <- enabled.transitions(pn)
    enabled <- (1:pn$t)[isenabled==TRUE]

    # Check if high.priority.trans is one of the enabled transitions
    if (!missing(high.priority.trans)) {
        fire.enabled.trans.ix <- grep(high.priority.trans, pn$trans$name)
        if (length(fire.enabled.trans.ix) == 0) fire.enabled.trans.ix <- 0
    } else fire.enabled.trans.ix <- 0

    #Step counter.
    stepCounter <- 1

    #Write header if reset
    if (reset) {
        names <- paste("\"",paste(pn$places$name,col="\""),sep="")
        cat("time\ttrans\t",names,"\n",file=file,append=FALSE)
    }
    #Loop until there are no more possible transitions
    while (length(enabled)>0 && (stepCounter <= steps)) {
        #If no transition rates then ordinary token
        if (is.null(pn$Lambda)) {
            timestep <- 1
            #select one of the enabled transitions by chance.
            #if length==1 sample doesnt work so we got to branch on it
            if (length(enabled) == 1) {
                seltrans <- enabled
            } else {
                if (fire.enabled.trans.ix == 0) {
                    seltrans <- sample(enabled,size=1)
                } else seltrans <- fire.enabled.trans.ix
                cat(formatC(pn$time,format="f"),
                    "\tmultiple enabled transitions: ", pn$trans$name[enabled],
                    "\tfiring: ", pn$trans$name[seltrans], "\n", append=TRUE)
            }
        } else {
            #####################################################################
            ##Stochastic petri net -- possibly with state dependent rates
            #####################################################################

            #Deduce state dependent rates by calculating rate for
            #each enabled transition
            rates <- sapply(enabled,function(i) { pn$Lambda[[i]](pn$M)})

            #Sample waiting time for each
            waits <- rexp(length(enabled),rates)
            #Race against the machine - the fastest wins
            seltrans <- enabled[which.min(waits)]
            timestep <- min(waits)
        }

        #Fire the transition and update marking.
        pn$M <- pn$M + pn$C[seltrans,]
        pn$time <- pn$time + timestep

        #Log info - Debug info.
#         cat("writing to log file: ", formatC(pn$time,format="f"),"\t",
#             seltrans,"\t",pn$M,"\n", append=TRUE)
        cat(formatC(pn$time,format="f"),"\t",seltrans,"\t",pn$M,"\n",
            file=file,append=TRUE)
        #!(reset & (stepCounter==1)))

        #Plot it.
        if (animate) {print(ggplot.petrinet(pn))}

        #Wait
        for (i in 1:wait*timestep) {}

        #Find the new set of enabled transitions.
        isenabled <- enabled.transitions(pn)
        enabled <- (1:pn$t)[isenabled==TRUE]

        #Did one step
        stepCounter <- stepCounter + 1;
    }
    invisible(pn)
}

######################################################################
# Check if a sequence of transitions (replay) is valid in Petri-Net simulation
#
# Params:
#   pn - Obj. of class petrinet to be simulated
#   replay.trans - sequence of transitions to be replayed
#       e.g. c("a", "b", "c", "d")
#       e.g. "a,b,c,d"
#
# Returns: list of 
#   tcf - Token based Conformance Fitness metric
#   tokens_p - tokens produced
#   tokens_c - tokens consumed
#   tokens_m - tokens missing
#   tokens_r - tokens remaining
######################################################################
replay.petrisim <- function(pn, replay.trans) {
#     print(ggplot.petrinet(pn))
#     par(ask=TRUE) 

    if (length(replay.trans) == 1)
        replay.trans <- unlist(strsplit(replay.trans,"[,]"))

    first <- TRUE; replay_pn <- pn;
    tokens_p <- tokens_c <- sum(pn$M0)
    tokens_m <- tokens_r <- 0
    for (tix in 1:length(replay.trans)) {
        trans <- replay.trans[tix]
        
        # if trans does not exist in pn skip it
        if (length(grep(trans, replay_pn$trans$name, fixed=TRUE)) == 0) {
#             warning("Transition: ", trans, " not present; terminating replay")
#             print(ggplot.petrinet(replay_pn))
#             break

            warning("Transition: ", trans, " not present; skipping transition")
#            print(ggplot.petrinet(replay_pn))
            next
        }
        
        if (!enabled.transitions(replay_pn)[trans]) {
            warning("Transition: ", trans, " not enabled; adding missing token(s)")
            for (place in replay_pn$places$name[replay_pn$Cin[trans, ] == 1]) {
                if (replay_pn$M[replay_pn$places$id[replay_pn$places$name == place]] == 0) {
                    tokens_m <- tokens_m + 1
                    replay_pn$M[replay_pn$places$id[replay_pn$places$name == place]] <- 1
                    warning("Place: ", place, ": added 1 missing token")
                }
            }
            first <- FALSE  # if first is TRUE, token.game will reset tokens
        }
        
        tokens_c <- tokens_c + sum(replay_pn$Cin[trans, ])
        last <- ifelse((tix == length(replay.trans)), TRUE, FALSE)
        replay_pn <- token.game(replay_pn, steps=1, high.priority.trans=trans,
                                animate=last, reset=first, wait=100)
        tokens_p <- tokens_p + sum(replay_pn$Cout[trans, ])                        
        first <- FALSE
    }
    
    if (replay_pn$M[replay_pn$p] == 0)  { # missing token in "end" place 
        tokens_m <- tokens_m + 1
        replay_pn$M[replay_pn$p] <- 1
    }    
    
#     tokens_r <- sum(replay_pn$M) - 
#                     # minus valid tokens in final place assuming first transition was fired
#                     ifelse((replay_pn$M[1] == 0), pn$M0[1], 0)     
#     if (replay_pn$M[1] == 0) {
#         # minus valid tokens in final place assuming first transition was fired
#         tokens_r <- sum(replay_pn$M) - pn$M0[1]
#     } else tokens_r <- sum(replay_pn$M)   
    tokens_r <- sum(replay_pn$M) - pn$M0[1]
    
    par(ask=FALSE)
    tcf <- 0.5 * (1 - ((tokens_m * 1.0) / tokens_c)) + 
           0.5 * (1 - ((tokens_r * 1.0) / tokens_p))
    return(list(tcf=tcf, 
                tokens_p=tokens_p, tokens_c=tokens_c, tokens_m=tokens_m, tokens_r=tokens_r))       
}

######################################################################
# Depth first search of Petri-Net simulation
#
# Params:
#   pn - Obj. of class petrinet to be analyzed.
#   indent - diagnostics indentation
#   maxsteps - guard against infinite recursive loop
#       uses dfs.petrisim_steps in parent environment (very RUDE ?)
#   file - The log file - typically generated by token.game
#
# Returns:
#   a petrinet with leaf marking ?
######################################################################
dfs.petrisim <- function(pn, indent=0, maxsteps=50, file) {
    # guard against infinite recursive loop
    if ((indent > 5) | (dfs.petrisim_steps >= maxsteps)) {
        warning("stopping: might be in infinite recursive loop")
#         stop()
#         invisible(pn)
        tmp_pn <- pn
        tmp_pn$M <- rep(0, nrow(pn$places))
        tmp_pn$M0 <- tmp_pn$M
        invisible(tmp_pn)
#         invisible(NULL)
    }

    lvl_pn <- pn
    lvl_enabled_trans <- enabled.transitions(lvl_pn)
    if (sum(lvl_enabled_trans) == 0) {
        # reached a leaf
        invisible(lvl_pn)
    } else if (sum(lvl_enabled_trans) == 1) {
        while(sum(lvl_enabled_trans) == 1) {
            if ((indent > 5) | (dfs.petrisim_steps >= maxsteps)) {
                warning("stopping: might be in infinite recursive loop")
                stop()
                #         tmp_pn <- pn
                #         tmp_pn$M <- rep(0, nrow(pn$places))
                #         tmp_pn$M0 <- tmp_pn$M
                #         invisible(tmp_pn)
                invisible(lvl_pn)
            }

            dfs.petrisim_steps <<- dfs.petrisim_steps + 1
            lvl_pn <- token.game(lvl_pn, steps=1, animate=FALSE, reset=FALSE,
                                 wait=100, file=file)
            lvl_enabled_trans <- enabled.transitions(lvl_pn)
        }
        lvl_pn <- dfs.petrisim(lvl_pn, indent=indent+1, file=file)
        invisible(lvl_pn)
    } else {
        for (lvl_trans_ix in 1:length(lvl_enabled_trans)) {
            if (lvl_enabled_trans[lvl_trans_ix]) {
                dfs.petrisim_steps <<- dfs.petrisim_steps + 1
                indent_prefix <- paste0(rep("    ", indent), collapse="")
                #       print(sprintf("%slvl_trans: %s; i am here", indent_prefix,
                #                               lvl_pn$trans$name[lvl_trans_ix]))
                nxt_pn <-
                    token.game(lvl_pn,
                            high.priority.trans=lvl_pn$trans$name[lvl_trans_ix],
                        steps=1, animate=FALSE, reset=FALSE,  wait=100, file=file)
                nxt_pn <- dfs.petrisim(nxt_pn, indent=indent+1, file=file)
            }
        }
        invisible(nxt_pn)
    }
}

######################################################################
#Estimate transition rate matrix of a continous time markov chain.
#
#Parameters:
# times - time of change from one state to another
# states - sequence of states of the embedded chain
######################################################################
ctmc.estimate.trm <- function(times,states) {
    #Count total time spent in each state
    wait <- diff(times)
    gamma <- as.numeric(tapply(wait,states[-length(states)],sum))

    #How many different states?
    k <- length(unique(states))

    #count number of jumps from state i to state j
    n <- table(states[-length(states)],states[-1])
    #lambda_ij = n_ij / gamma_i, i.e. divide gamma column wise.
    Lambda <- n / matrix(gamma,k,k)
    #Ensure row sum is 0 in each, i.e. fix diagonal.
    diag(Lambda) <- -apply(Lambda,1,sum)

    #Done
    return(Lambda)
}

######################################################################
#Calculate stationary distribution of a CTMC given its
#transition rate matrix.
#
#Params:
# Lambda - Transition Rate Matrix.
######################################################################
ctmc.stationary <- function(Lambda) {
    #Use calculation directly on Lambda - alternative: using the embedded.
    #Problem: Lambda is singular, constraint of \sum pi  = 1 has to be
    #builtin.
    U <- t(Lambda)
    U[nrow(U),] <- 1
    pi <- solve(U,c(rep(0,nrow(U)-1),1))
    names(pi) <- dimnames(U)[[1]]

    return(pi)
}

######################################################################
# Analyze the log file of a Petri-Net simulation
#
# Params:
#  pn - Obj. of class petrinet to be anaylsed.
#  file - The log file - typically generated by token.game
#  burnin - In case the initial burnin samples should be skipped.
#  stationary - Deduce stationary distribution from empirical state space
#               in case state space is large this can be quite heavy!!
#
# Returns:
#  the entire log file.
######################################################################
analyze.petrisim <- function(pn,file="log.txt",burnin=0,stationary=FALSE) {
    #Analyze log files.
    log <- read.table(paste(file,sep=""),header=TRUE)
    #Remove burnin to steady state.
    if (burnin>0) {log <- log[-c(1:burnin),]}

    #No of sims
    n <- nrow(log)
    #Col index of places
    places <- 3:(3+pn$p-1)

    ##Find all possible markings in the log file. I.e.
    ##convert places log to strings using paste by surfing the rows.
    M <- apply(log[,places],MARGIN=1,paste,sep="",collapse="|")
    M <- factor(M)

    # List all unique markings (states)
    markings_df <- data.frame(marking_id=1:(length(levels(M))+1))
    markings_df[, pn$places$name] <- NA
    markings_df[1, pn$places$name] <- pn$M0
    for (marking_ix in 1:length(levels(M)))
        markings_df[marking_ix+1, pn$places$name] <-
        as.numeric(unlist(strsplit(levels(M)[marking_ix], "[|]")))
    markings_df$initial <- c(1, rep(0, nrow(markings_df)-1))
    markings_df$final <- sapply(1:nrow(markings_df),
                function(row_ix) {
                    tmp_pn <- pn
                    tmp_pn$M <- as.numeric(markings_df[row_ix, pn$places$name])
                    tmp_pn$M0 <- tmp_pn$M
                    return(ifelse(sum(enabled.transitions(tmp_pn)) > 0, 0, 1))})
    #print(markings_df)

    #Max number of tokens in the system
    maxTok <- max(log[,places])

    ##Make a ts-plot of no. of tokens at each place over time
    matplot(log$time,log[,places],type="h",main="No. of Tokens over time",
            ylab="No of tokens @ place",xlab="time")
    legend(3/4*max(log$time),maxTok,dimnames(log)[[2]][places],lty=1,col=1:length(places))

    #Running mean of.
    matplot(log$time,apply(log[,places],2,cumsum)/(1:n),type="l",
            lty=2,main="Running means",xlab="t",ylab="Running mean of no. of tokens")

    legend(3/4*max(log$time),maxTok,dimnames(log)[[2]][places],lty=1,col=1:length(places))

    ##Mean number of tokens.
    tokentab <- apply(log[,places],2,mean)
    ##Mean number of firings.
    transtab <- table(log$trans)/length(log$trans)
    names(transtab) <- pn$trans$name

    #show summary?
    print("Unique markings:")
    print(markings_df)
    print("Mean no. of tokens of embedded chain")
    print(tokentab)
    print("Distribution of firings.")
    print(transtab)
    par(mfcol=c(2,1))
    barplot(tokentab,main="Mean number of tokens at place.")
    barplot(t(transtab),main="Empirical distribution of firing transition")
    par(mfcol=c(1,1))


    if (stationary) {
        #Estimate transition rate matrix
        Lambda.pn <- ctmc.estimate.trm(log$time,M)
        #Based on this find approximate (all states are not observed)
        #stationary distribution.
        pi.pn   <- ctmc.stationary(Lambda.pn)
        #Show results.
        #print(Lambda.pn)
        print("Stationary distribution:")
        print(pi.pn)
        barplot(pi.pn,type="h",cex.names=0.6,las=2)
    } else {
        pi.pn <- NULL
        Lambda.pn <- NULL
    }

    invisible(list(log=log,pi=pi.pn,Lambda=Lambda.pn))
}

######################################################################
# Find unique transitions in a trace(log) stream
#   helper function for inferring traces footprint matrix & alpha algorithm
#
# Params:
#  traces_df - data.frame containing comma separated transitions as column "trace"
#               e.g. "a, b, c, d, e"
#
# Returns:
#  a vector of unique transitions
######################################################################
unique.trans <- function(traces_df) {
    return(unique(unlist(strsplit(paste0(unique(traces_df$trace), collapse=","),
                                  split=","))))
}
first.trans <- function(traces_df) {
    trans.set <- c()
    for (trc in traces_df$trace)
        trans.set <- union(trans.set, unlist(strsplit(trc, split=","))[1])

    return(trans.set)
}
last.trans <- function(traces_df) {
    trans.set <- c()
    for (trc in traces_df$trace)
        trans.set <- union(trans.set, tail(unlist(strsplit(trc, split=",")), 1))

    return(trans.set)
}

######################################################################
# Create footprint matrix of a trace(log) stream
#
# Params:
#  traces_df - data.frame containing comma separated transitions as column "trace"
#               e.g. "a, b, c, d, e"
#
# Returns:
#  footprint matrix
######################################################################
footprint.traces <- function(traces_df) {
    unique_trans <- sort(unique.trans(traces_df))
    L_mtrx <- matrix(rep("#", length(unique_trans) ^ 2),
                            nrow=length(unique_trans),
                            dimnames=list(unique_trans, unique_trans))

    # Flag tx > ty pairs
    for (trc in 1:nrow(traces_df)) {
        transs <- unlist(strsplit(traces_df$trace[trc], split=","))
        for (trs in 1:length(transs)) {
            if (trs != length(transs)) {
                L_mtrx[transs[trs], transs[trs+1]] <- ">"
            }
        }
    }

    # Flag tx -> & <- ty pairs
    for (i in 1:nrow(L_mtrx))
        for (j in 1:nrow(L_mtrx)) {
            if ((L_mtrx[i, j] == ">") & (L_mtrx[j, i] != ">")) {
                L_mtrx[i, j] <- "->"; L_mtrx[j, i] <- "<-"
            }
        }

    # Flag tx || ty pairs
    for (i in 1:nrow(L_mtrx))
        for (j in 1:nrow(L_mtrx)) {
            if ((L_mtrx[i, j] == ">") & (L_mtrx[j, i] == ">")) {
                L_mtrx[i, j] <- "||"; L_mtrx[j, i] <- "||"
            }
        }

    return(L_mtrx)
}

freq.traces <- function(traces_df) {
    unique_trans <- unique.trans(traces_df)
    L_freq_mtrx <- matrix(rep(0, length(unique_trans) ^ 2),
                     nrow=length(unique_trans),
                     dimnames=list(unique_trans, unique_trans))

    # Count direct succession freq by trace
    for (trc in 1:nrow(traces_df)) {
        transs <- unlist(strsplit(traces_df$trace[trc], split=","))
        for (trs in 1:length(transs)) {
            if (trs != length(transs)) {
                L_freq_mtrx[transs[trs], transs[trs+1]] <-
                    L_freq_mtrx[transs[trs], transs[trs+1]] + 1
            }
        }
    }

    return(L_freq_mtrx)
}

dependency.traces <- function(L_freq_mtrx) {
    L_depnd_mtrx <- matrix(rep(0, nrow(L_freq_mtrx) ^ 2),
                          nrow=nrow(L_freq_mtrx),
                          dimnames=dimnames(L_freq_mtrx))

    # Compute dependencies for each element in matrix
    for (row in 1:nrow(L_freq_mtrx))
        for (col in 1:ncol(L_freq_mtrx))
            if (row == col) {
                L_depnd_mtrx[row, col] <-
                    (L_freq_mtrx[row, col] * 1.0) / (L_freq_mtrx[row, col] + 1)
            } else {
                L_depnd_mtrx[row, col] <-
                    ((L_freq_mtrx[row, col] * 1.0) -
                     (L_freq_mtrx[col, row] * 1.0)) /
                    (L_freq_mtrx[row, col] + L_freq_mtrx[col, row] + 1)
            }

    return(L_depnd_mtrx)
}

token.fitness.traces <- function(pn, traces_df) {
    require(plyr)

    tokens_p <- tokens_c <- tokens_m <- tokens_r <- 0
    
    unique_traces_df <- ddply(traces_df, .(traces_df$trace), nrow)
    names(unique_traces_df) <- c("trace", "freq")
    
    for (row_pos in 1:nrow(unique_traces_df)) {
        fitness_lst <- replay.petrisim(pn, unique_traces_df[row_pos, "trace"])
        tokens_p <- tokens_p + fitness_lst$tokens_p * unique_traces_df[row_pos, "freq"]
        tokens_c <- tokens_c + fitness_lst$tokens_c * unique_traces_df[row_pos, "freq"]
        tokens_m <- tokens_m + fitness_lst$tokens_m * unique_traces_df[row_pos, "freq"]
        tokens_r <- tokens_r + fitness_lst$tokens_r * unique_traces_df[row_pos, "freq"]                        
    }

    tcf <- 0.5 * (1 - ((tokens_m * 1.0) / tokens_c)) + 
           0.5 * (1 - ((tokens_r * 1.0) / tokens_p))
    return(list(tcf=tcf, 
                tokens_p=tokens_p, tokens_c=tokens_c, tokens_m=tokens_m, tokens_r=tokens_r))       
}

alignment.fitness.trace <- function(shortest_path_trace, trace) {
}

######################################################################
# Create Xl pairs of footprint matrix of a trace(log) stream
#
# Params:
#  L_mtrx 
#
# Returns:
#  dataframe of Xl pairs
######################################################################
Xl.pairs <- function(L_mtrx) {
    require(doBy)
    require(plyr)

    pairs_df <- data.frame(A=NULL, B=NULL)

    # all A single element pairs
    for (trs in 1:nrow(L_mtrx)) {
        #print(sprintf("trs: %d", trs))
        if (L_mtrx[trs, trs] != "#") next
        
        L_trs_row <- L_mtrx[trs, ]
        L_trs_row <- L_trs_row[L_trs_row == "->"]
        if (length(L_trs_row) == 0) next
        for (B_n in 1:length(L_trs_row)) {
            #print(sprintf("B_n: %d", B_n))
            B_n_combns_mtrx <- combn(names(L_trs_row), B_n)
            for (B_trs_col_ix in ncol(B_n_combns_mtrx):1) {
                # check if all pairs in this B column are #
                B_trs_col <- B_n_combns_mtrx[, B_trs_col_ix];  valid <- TRUE
                for (B_trs_elem_ix in 1:length(B_trs_col))
                    if (valid &
                        (L_mtrx[B_trs_col[1], B_trs_col[B_trs_elem_ix]] != "#")) {
                        valid <- FALSE; next
                    }
                if (!valid) {
                    # remove column from B_n_combns_mtrx
                    B_n_combns_mtrx <- matrix(B_n_combns_mtrx[, -B_trs_col_ix],
                                                 nrow=nrow(B_n_combns_mtrx))
                }
            }
            if (ncol(B_n_combns_mtrx) > 0)
            {
                pairs_df <- rbind(pairs_df,
    data.frame(A=rep(row.names(L_mtrx)[trs], ncol(B_n_combns_mtrx)),
                B=sapply(1:ncol(B_n_combns_mtrx),
                    function(col) paste0(B_n_combns_mtrx[, col], collapse=",")),
               stringsAsFactors=FALSE))
            }
        }
    }

    if (nrow(pairs_df) == 0) return(pairs_df)

    # collect & check multiple A element pairs
    pairs_df <- orderBy(~B+A, pairs_df)
    counts_df <- ddply(pairs_df, .(pairs_df$B), nrow)
    names(counts_df) <- c("B", "freq")
    counts_df <- subset(counts_df, freq > 1)
    for (B in counts_df$B) {
        A_union <- unique(pairs_df[pairs_df$B == B, "A"])
        if (length(A_union) < 2) next
        for (A_n in 2:length(A_union)) {
            #print(sprintf("B_n: %d", B_n))
            A_n_combns_mtrx <- combn(A_union, A_n)
            for (A_trs_col_ix in ncol(A_n_combns_mtrx):1) {
                # check if all pairs in this A column are #
                A_trs_col <- A_n_combns_mtrx[, A_trs_col_ix];  valid <- TRUE
                for (A_trs_elem_ix in 1:length(A_trs_col))
                    if (valid &
                        (L_mtrx[A_trs_col[1], A_trs_col[A_trs_elem_ix]] != "#")) {
                        valid <- FALSE; next
                    }
                if (!valid) {
                    # remove column from A_n_combns_mtrx
                    A_n_combns_mtrx <- matrix(A_n_combns_mtrx[, -B_trs_col_ix],
                                                 nrow=nrow(A_n_combns_mtrx))
                }
            }
            if (ncol(A_n_combns_mtrx) > 0)
            {
                pairs_df <- rbind(pairs_df,
                                  data.frame(
                                             A=sapply(1:ncol(A_n_combns_mtrx),
                    function(col) paste0(A_n_combns_mtrx[, col], collapse=",")),
                                             B=rep(B, ncol(A_n_combns_mtrx)),
                                             stringsAsFactors=FALSE))
            }
        }
    }

    return(orderBy(~A+B, pairs_df))
}

######################################################################
# Create petrinet of a trace(log) stream using alpha algorithm
#
# Params:
#  traces_df - data.frame containing comma separated transitions as column "trace"
#               e.g. "a, b, c, d, e"
#
# Returns:
#  petrinet object
######################################################################
alpha.petrinet <- function(traces_df) {
    L_mtrx <- footprint.traces(traces_df); print(L_mtrx)
    
    Tl <- unique.trans(traces_df); print(Tl)
    Ti <- first.trans(traces_df);  print(Ti)
    To <- last.trans(traces_df);   print(To)
    
    Xl_df <- Xl.pairs(L_mtrx); print(Xl_df)
    
    select_maximal_pairs <- function(pairs_df, dups_col, sets_col)
    {
        require(doBy)
        require(plyr)
        require(gtools)

        if (nrow(pairs_df) == 0) return(pairs_df)
        
        pairs_df <- orderBy(as.formula(paste0("~", dups_col, "+", sets_col)), pairs_df)
        pairs_df$maximal <- TRUE

        # Check all dups of dups_col
        counts_df <- ddply(pairs_df, .(pairs_df[, dups_col]), nrow)
        names(counts_df) <- c(dups_col, "freq")
        counts_df <- subset(counts_df, freq > 1)
        pairs_df$sets_union <- NA
            
        for (value in counts_df[, dups_col]) {
            unique_sets <- unique(pairs_df[pairs_df[, dups_col] == value, sets_col])
            # Generate value possible permutations
            unique_sets_save <- unique_sets
            for (this_set in unique_sets_save) {
                #print(sprintf("this_set: %s", this_set))
                this_set_elems <- unlist(strsplit(this_set, split="[,]"))
                if (length(this_set_elems) <= 1) next
                perms <- permutations(length(this_set_elems), length(this_set_elems), 
                                      this_set_elems)
                #print(perms)
                for (row in 1:nrow(perms)) {
                    this_perm <- paste0(perms[row, ], collapse=",")
                    if (length(grep(this_perm, unique_sets)) == 0)
                        unique_sets <- c(unique_sets, this_perm)
                }
            }
            pairs_df[pairs_df[, dups_col] == value, "sets_union"] <-
                paste0(unique_sets, collapse="|")
        }
        
        pairs_df$maximal <- sapply(1:nrow(pairs_df),
            function(row) 
#             ifelse((pairs_df[row, "maximal"] &
#                                 !is.na(pairs_df[row, "sets_union"]) &
#                                 (length(grep(pairs_df[row, sets_col],
#                             unlist(strsplit(pairs_df[row, "sets_union"], split="[|]")),
#                             fixed=TRUE)) > 1)),
#                                           FALSE, TRUE)  # first ifelse
            ifelse(is.na(pairs_df[row, "sets_union"]), TRUE, 
                #FALSE
                ifelse((pairs_df[row, "maximal"] &
                                (length(grep(pairs_df[row, sets_col],
                            unlist(strsplit(pairs_df[row, "sets_union"], split="[|]")),
                            fixed=TRUE)) > 1)), FALSE, TRUE)
                  )  # first ifelse
                                  ) # sapply

        pairs_df <- subset(pairs_df, maximal)
        
        return(pairs_df[, c(dups_col, sets_col)])
    }

    Yl_df <- select_maximal_pairs(Xl_df, dups_col="A", sets_col="B")
    Yl_df <- select_maximal_pairs(Yl_df, dups_col="B", sets_col="A")
    if (nrow(Yl_df) == 0) {
        warning("No places found")
        return(NULL)
    }

    places_df <- data.frame(id=2:(nrow(Yl_df)+1),
                                   name=paste0("p", 1:nrow(Yl_df)),
                                   x=(1:nrow(Yl_df))*10,
                                   y=rep(0, nrow(Yl_df)),
                                   M0=rep(0, nrow(Yl_df)),
                                   A=Yl_df$A, B=Yl_df$B,
                                   stringsAsFactors=FALSE)
    places_df <- orderBy(~id,
                                rbind(places_df,
                                    data.frame(id=c(1, nrow(places_df)+2),
                                         name=c("start", "end"),
                                         x=c(0, (nrow(places_df)+1)*10),
                                         y=rep(0, 2),
                                         M0=c(1, 0),
                                         A=rep(NA, 2), B=rep(NA, 2),
                                  stringsAsFactors=FALSE)))
    print(places_df)
    
    trans_df <- data.frame(id=1:length(unique.trans(traces_df)),
                              name=unique.trans(traces_df),
                              x=(1:length(unique.trans(traces_df))) * 5,
    y=rep(c(5, -5), ceiling(length(unique.trans(traces_df)) / 2))[
        1:length(unique.trans(traces_df))],
                              stringsAsFactors=FALSE)
    trans_df[trans_df$name %in%
                        first.trans(traces_df), "first"] <- 1
    trans_df[trans_df$name %in%
                        last.trans(traces_df), "last"] <- 1
    print(trans_df)

    arcs_df <- data.frame(
        begin=rep("start", nrow(subset(trans_df, first==1))),
        end=subset(trans_df, first==1)$name,
                                stringsAsFactors=FALSE)
    for (place_ix in 2:(nrow(places_df)-1)) {
        arcs_df <- rbind(arcs_df, data.frame(
            end=rep(places_df[place_ix, "name"] ,
                    length(unlist(strsplit(places_df[place_ix, "A"], "[,]")))),
            begin=unlist(strsplit(places_df[place_ix, "A"], "[,]")),
            stringsAsFactors=FALSE))
        arcs_df <- rbind(arcs_df, data.frame(
            begin=rep(places_df[place_ix, "name"] ,
                    length(unlist(strsplit(places_df[place_ix, "B"], "[,]")))),
            end=unlist(strsplit(places_df[place_ix, "B"], "[,]")),
            stringsAsFactors=FALSE))
    }
    arcs_df <- rbind(arcs_df, data.frame(
        end=rep("end", nrow(subset(trans_df, last==1))),
        begin=subset(trans_df, last==1)$name,
        stringsAsFactors=FALSE))
    print(arcs_df)

    pn <- petrinet(name="pn",
                          trans_df=trans_df,
                          places_df=places_df,
                          arcs_df=arcs_df)

    print(ggplot.petrinet(pn))
    return(pn)
}

######################################################################
# Compute footprint matrix conformance
#
# Params:
#  truth_L_mtrx:    typically generated by footprint.traces()
#  compare_L_mtrx:
#
# If compare_L_mtrx does not contain rows / cols that is present in truth_L_mtrx
#    the cells are assumed to be "#" in compare_L_mtrx
# If compare_L_mtrx contains rows / cols that are not present in truth_L_mtrx
#   those cells are ignored
#
# Returns:
#  conformance metric: 1 - (number of unequal_cells) / (number of total cells)   
######################################################################
footprint.conformance <- function(truth_L_mtrx, compare_L_mtrx) {
    if ((dim(compare_L_mtrx)[1] > dim(truth_L_mtrx)[1]) |
        (dim(compare_L_mtrx)[2] > dim(truth_L_mtrx)[2]))
        warning("Additional rows/cols ignored in compare_L_mtrx dims: ",
                dim(compare_L_mtrx), "vs. truth_L_mtrx dims: ",
                dim(compare_L_mtrx))

    equal_cell_n = 0
    for (row in dimnames(truth_L_mtrx)[[1]]) {
        if (!(row %in% dimnames(compare_L_mtrx)[[1]])) {
            # Assume compare_L_mtrx contains all '#' in this row
            equal_cell_n <- equal_cell_n + sum(truth_L_mtrx[row, ] == "#")
        } else {
            for (col in dimnames(truth_L_mtrx)[[2]]) {
                if (!(col %in% dimnames(compare_L_mtrx)[[2]])) {
                    # Assume compare_L_mtrx contains '#' in this cell
                    if (truth_L_mtrx[row, col] == "#")
                        equal_cell_n <- equal_cell_n + 1
                } else {
                    #if (!is.na(compare_L_mtrx[row, col])) {
                        if (compare_L_mtrx[row, col] == truth_L_mtrx[row, col])
                            equal_cell_n <- equal_cell_n + 1
                    #}
                }
            }
        }
        #print(sprintf("row %s: %d", row, equal_cell_n))
    }

    return(1 - ((((dim(truth_L_mtrx)[1] ^ 2) - equal_cell_n) * 1.0)
                / (dim(truth_L_mtrx)[1] ^ 2)))
}
