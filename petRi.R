###################################################
### chunk number 1: 
###################################################
######################################################################
# Author: Michael Höhle <hoehle@stat.uni-muenchen.de>
# Date:   11 July 2004
#
# Petri nets in R. A small reader and player for 
# ordinary petri nets generated by CPN Tools (wiki.daimi.au.dk/cpntools).
# In R the Petri  Net can be annotated with simple
# stochastic petri net features.
#
# License:
#  GPL (see license.txt)
#
# Requirements:
#  XML Package (http://www.omegahat.org/RSXML/)
#  msm Package
#
# Comments:
#  To find a Windows binary of the XML Package use
#  http://www.stats.ox.ac.uk/pub/RWin
#
# Features:
#  * animated token game
#  * simulation to log file
#  * generalized stochastic petri nets by defining delay function distribution
#    this can be state dependent etc.
#
# Known bugs:
#  - fancy arrow drawing with curves is ignored.
#  - colored petri nets not supported. All types have to be INT
#    and only supported type is 1, i.e 12`1 works.
#
# ToDo:
#  - R Package
######################################################################



###################################################
### chunk number 2: 
###################################################
######################################################################
# CPN Tools XML reader.
#######################################################################

load.cpn <- function(cpnFile) {
  #The split of the base c:/../../../<baseName>.cpn
  split <- strsplit(strsplit(cpnFile,".",fixed=TRUE)[[1]],"/")[[1]]
  baseName <- split[length(split)]
  folder   <- paste(paste(split[-length(split)],collapse="/"),"/",sep="")

  #Read XML File and go to page definition directly - this rocks!!
  doc <- xmlTreeParse(cpnFile)
  page <- xmlRoot(doc)[["cpnet"]][["page"]]

  ######################################################################
  #Small helper function to convert a list found by
  #xmlApply to a data.frame. 
  ######################################################################
  l2df <- function(l,colNames,num) {
    foo <- matrix(unlist(l),ncol=length(colNames),byrow=TRUE)
    foo <- data.frame(foo[!is.na(foo[,1]),])
    names(foo) <- colNames
    
    #Make all required numeric (this sucks)
    for (col in 1:length(num)) {
      #convert to string
      foo[,col] <- levels(foo[,col])[as.integer(foo[,col])]
      #go numeric if required.
      if (num[col]) { foo[,col] <- as.numeric(foo[,col])}
    }
    return(foo)
  }

  #Extract Handler for Places and Transitions
  exPlaceTrans <- function(x) {
    if ((xmlName(x) == "place") | (xmlName(x)=="trans")) {
      #Type
      type <- substr(xmlName(x),1,1)
      #Fetch the ID
      id <- xmlAttrs(x)
      #Fetch the name
      name <- xmlValue(x[["text"]])
      #Return x and y location
      xy <- as.numeric(xmlAttrs(x[["posattr"]]))
      #Fetch initial marking - doesnt work for multiset.
      if (type == "p") {
        M0 <- xmlValue(x[["initmark"]][["text"]])
        #Empty equals 0
        if (M0 == "empty") { M0 <- 0}
        #In case of multiset notation x`y we only support x.
        M0 <-sub("\`[[:digit:]]+", "",M0)
      } else {
        M0 = NA
      }
      return(c(id,type,name,xy,M0))
    } else {
      return(c(NA,NA,NA,NA,NA,NA))
    }
  }
  #Extract places and transitions. We do a further split
  pn <-  l2df(xmlApply(page,exPlaceTrans),c("id","type","name","x","y","M0"),
              c(FALSE,FALSE,FALSE,TRUE,TRUE,TRUE))


  #Define places - better to call xmlApply for places and
  #transitions seperatly?
  places <- pn[pn$type == "p",c("id","name","x","y","M0")]
  #Define transitions
  trans <- pn[pn$type == "t",c("id","name","x","y")]
  

  exArcs <- function(x) {
    if ((xmlName(x) == "arc")) {
      #Fetch the ID and orientation
      idori <- xmlAttrs(x)
      #Transition
      t <- xmlAttrs(x[["transend"]])
      #Place
      p <- xmlAttrs(x[["placeend"]])
      #Weight - multiset expressions are replcaed
      n <-sub("\`[[:digit:]]+", "", xmlValue(x[["annot"]][["text"]]))
      return(c(idori,p,t,n))
    } else {
      return(c(NA,NA,NA,NA,NA))
    }
  }
  #Extract arrows 
  arcs <- l2df(xmlApply(page,exArcs),c("id","ori","p","t","n"),c(FALSE,FALSE,FALSE,FALSE,TRUE))

  #No of places
  p <- nrow(places)
  #No of transitions
  t <- nrow(trans)

  #Should also come from file -- p.t. too difficult.
  pids <- places$id
  tids <- trans$id
 
  #A p \times t matrix.
  Cin <- matrix(0,t,p)
  Cout <- matrix(0,t,p)

  #Attach correct names to C'tables
  dimnames(Cin) <- list(trans$name,places$name)
  dimnames(Cout) <- list(trans$name,places$name)
  
  #Loop over all arcs and deduce Cin and Cout matrices.
  #Currently only 0 1 values are handled. Has to be improved.
  for (a in 1:nrow(arcs)) {
    arc <- arcs[a,]
    #Find which place and transition it goes to.
    pindx <- match(arc$p,pids)
    tindx <- match(arc$t,tids)

    #Update the arc in the appropriate invariant matrix.
    if (arc$ori == "PtoT") {
      Cin[tindx,pindx] <- arc$n
    } else {
      Cout[tindx,pindx] <- arc$n
    }
  }
  
  #Update Matrix (i.e. token transition)
  C <- Cout - Cin

  ##Use initital marking from CPN File and give names.
  M <- places$M0

  #Initial time
  time <- 0

  #Define petri net object using a list construct.
  pn <- list(trans=trans,places=places,Cin=Cin,Cout=Cout,C=C,
             p=p,t=t,M0=M,M=M,time=time)
  
  class(pn) <- "petrinet"
  return(pn)
}


###################################################
### chunk number 3: 
###################################################
######################################################################
# Plot a Petri net with initial marking.
#
# Params:
#  pn - the petri net to draw
#  draw.enabled - boolean, all enabled transitions are shown as green
######################################################################

plot.petrinet <- function(x,...) {
  #Hack stuff to get from S3 representation to a more readable thing.
  pn <- x
  opts <- list(...)
  #Draw places and transitions
  rx <- range(pn$places$x,pn$trans$x)
  ry <- range(pn$places$y,pn$trans$y) 
  xlim = rx + c(-1,1)*diff(rx)/10
  ylim = ry + c(-1,1)*diff(ry)/10
  dx <- diff(xlim)*1/15
  dy <- diff(ylim)*1/25
  #Different radia
  r1 <- 4/5*dx
  r2 <- 4/5*dy
  r3  <- dx/3
  #Draw places and transitions.
  plot(pn$places$x,pn$places$y,cex=10,xlim=xlim,ylim=ylim,axes=FALSE,xlab="",ylab="")
  rect(pn$trans$x-dx,pn$trans$y-dy,pn$trans$x+dx,pn$trans$y+dy)

  ######################################################################
  #Draw arrows by looping over all trans x places pairs.
  ######################################################################
  for (t in 1:nrow(pn$trans)) {
    for (p in 1:nrow(pn$places)) {
      #In arrows: place -> transition
      if (pn$Cin[t,p]>0) {
        #Show enabled transitions - if so then in green (col=3)?
        col <- opts$draw.enabled * enabled.transitions(pn)[t]*2+1
                      
        arrows(pn$places$x[p],pn$places$y[p],pn$trans$x[t],pn$trans$y[t],lwd=2,col=col)        
      }
      #Out arrows, i.e. transition -> place
      if (pn$Cout[t,p]>0) {
        arrows(pn$trans$x[t],pn$trans$y[t],pn$places$x[p],pn$places$y[p],lwd=2)
      }

      #show weight if greater than one
      cx <- (pn$places$x[p] + pn$trans$x[t])/2
      cy <- (pn$places$y[p] + pn$trans$y[t])/2
      if (pn$Cin[t,p]>1 )  { text(cx,cy,pn$Cin[t,p],cex=1.5,col=4)}
      if (pn$Cout[t,p]>1)  { text(cx,cy,pn$Cout[t,p],cex=1.5,col=4)}
      
    }
  }

  ######################################################################
  #Draw names
  ######################################################################
  text(pn$places$x,pn$places$y-dy,pn$places$name,col=4)
  text(pn$trans$x,pn$trans$y-dy,pn$trans$name)

  ######################################################################
  #Plot markings
  ######################################################################
  for (i in 1:pn$p) {
    mark <- pn$M[i]
    #If the place is marked then show all marks
    #Draw marks so its centered about the place's centre
    if (mark>0) {
      #Center
      cx <- pn$places$x[i]
      cy <- pn$places$y[i]
      #If there is only one mark its put in the center
      if (mark==1) {
        symbols(x=cx,y=cy,circles=dx/3,inches=FALSE,add=TRUE,bg=2)
      } else if (mark<5) {
        #If there are more than one angles and radius to place mark balls on
        angles <- (0:(mark-1))*2*3.141592/mark
        for (m in 1:mark) {
          symbols(x=cx+r1*cos(angles[m]),y=cy+r2*sin(angles[m]),circles=r3,inches=FALSE,add=TRUE,bg=2)
        } 
      } else {
        ##Too much to draw just print the number
        symbols(x=cx,y=cy,circles=2*r3,inches=FALSE,add=TRUE,bg=2)
        text(cx,cy,mark)
      }
    }
  }

  invisible()
}


###################################################
### chunk number 4: 
###################################################
###################################################################
# Generate a list of length equal to the no of transitions indicating
# for each whether it is enabled at the current marking or not.
###################################################################
enabled.transitions <- function(pn) {
  #Repeat Marking for each transition
  Mrep <- matrix(rep(pn$M,pn$t),pn$t,pn$p,byrow=TRUE)
  #Check that M>=Cin
  return(apply( Mrep >= pn$Cin,MARGIN=1,prod))
}


###################################################
### chunk number 5: 
###################################################
######################################################################
# Petri Net simulator. With our without animation.
#
# Params:
#  pn - petri net to work on
#  steps - number of steps to simulate
#  animate - play the token game and show the graphics
#  reset - start with M0 or continue on current marking
#  wait - waiting time to next move * timestep
#  file - logfile , default is stdout.
######################################################################

token.game <- function(pn,steps=1e99,animate=TRUE,reset=FALSE,
                       wait=1000000,file="") {
  #The rewind option goes back to the initial marking.
  if (reset) {pn$M <- pn$M0; pn$time = 0}
  
  #Find the set of enabled transitions.
  isenabled <- enabled.transitions(pn)
  enabled <- (1:pn$t)[isenabled==TRUE]

  #Step counter.
  stepCounter <- 1

  #Write header if reset
  if (reset) {
    names <- paste("\"",paste(pn$places$name,col="\""),sep="")
    cat("time\ttrans\t",names,"\n",file=file,append=FALSE)
  }
  #Loop until there are no more possible transitions
  while (length(enabled)>0 && (stepCounter <= steps)) {
    #If no transition rates then ordinary token
    if (is.null(pn$Lambda)) {
      timestep <- 1
      #select one of the enabled transitions by chance.
      #if length==1 sample doesnt work so we got to branch on it
      if (length(enabled) == 1) {
        seltrans <- enabled
      } else {
        seltrans <- sample(enabled,size=1)
      }
    } else {
      ######################################################################
      ##Stochastic petri net -- possibly with state dependent rates
      ######################################################################
      
      #Deduce state dependent rates by calculating rate for
      #each enabled transition
      rates <- sapply(enabled,function(i) { pn$Lambda[[i]](pn$M)})
      
      #Sample waiting time for each
      waits <- rexp(length(enabled),rates)
      #Race against the machine - the fastest wins
      seltrans <- enabled[which.min(waits)]
      timestep <- min(waits)
    }

    #Fire the transition and update marking.
    pn$M <- pn$M + pn$C[seltrans,]
    pn$time <- pn$time + timestep

    #Log info - Debug info.
    cat(formatC(pn$time,format="f"),"\t",seltrans,"\t",pn$M,"\n",file=file,append=TRUE)
    #!(reset & (stepCounter==1)))

    #Plot it.
    if (animate) {plot(pn,draw.enabled=TRUE)}

    #Wait
    for (i in 1:wait*timestep) {}
    
    #Find the new set of enabled transitions.
    isenabled <- enabled.transitions(pn)
    enabled <- (1:pn$t)[isenabled==TRUE]

    #Did one step
    stepCounter <- stepCounter + 1;
  }
  return(pn)
}


###################################################
### chunk number 6: 
###################################################
######################################################################
#Estimate transition rate matrix of a continous time markov chain.
#
#Parameters:
# times - time of change from one state to another
# states - sequence of states of the embedded chain
######################################################################
ctmc.estimate.trm <- function(times,states) {
  #Count total time spent in each state
  wait <- diff(times)
  gamma <- as.numeric(tapply(wait,states[-length(states)],sum))

  #How many different states?
  k <- length(unique(states))
  
  #count number of jumps from state i to state j
  n <- table(states[-length(states)],states[-1])
  #lambda_ij = n_ij / gamma_i, i.e. divide gamma column wise.
  Lambda <- n / matrix(gamma,k,k)
  #Ensure row sum is 0 in each, i.e. fix diagonal.
  diag(Lambda) <- -apply(Lambda,1,sum)

  #Done
  return(Lambda)
}


###################################################
### chunk number 7: 
###################################################
######################################################################
#Calculate stationary distribution of a CTMC given its
#transition rate matrix.
#
#Params:
# Lambda - Transition Rate Matrix.
######################################################################
ctmc.stationary <- function(Lambda) {
  #Use calculation directly on Lambda - alternative: using the embedded.
  #Problem: Lambda is singular, constraint of \sum pi  = 1 has to be
  #builtin.
  U <- t(Lambda)
  U[nrow(U),] <- 1
  pi <- solve(U,c(rep(0,nrow(U)-1),1))
  names(pi) <- dimnames(U)[[1]]

  return(pi)
}


###################################################
### chunk number 8: 
###################################################
######################################################################
# Analyze the log file of a Petri-Net simulation
#
# Params:
#  pn - Obj. of class petrinet to be anaylsed.
#  file - The log file - typically generated by token.game
#  burnin - In case the initial burnin samples should be skipped.
#  stationary - Deduce stationary distribution from empirical state space
#               in case state space is large this can be quite heavy!!
#
# Returns:
#  the entire log file.
######################################################################

analyze.petrisim <- function(pn,file="log.txt",burnin=0,stationary=FALSE) {
  #Analyze log files.
  log <- read.table(paste(file,sep=""),header=TRUE)
  #Remove burnin to steady state.
  if (burnin>0) {log <- log[-c(1:burnin),]}
  
  #No of sims
  n <- nrow(log)
  #Col index of places
  places <- 3:(3+pn$p-1)
  
  ##Find all possible markings in the log file. I.e.
  ##convert places log to strings using paste by surfing the rows.
  M <- apply(log[,places],MARGIN=1,paste,sep="",collapse="|")
  M <- factor(M)

  #Max number of tokens in the system
  maxTok <- max(log[,places])
      
  ##Make a ts-plot of no. of tokens at each place over time
  matplot(log$time,log[,places],type="h",main="No. of Tokens over time",
          ylab="No of tokens @ place",xlab="time")
  legend(3/4*max(log$time),maxTok,dimnames(log)[[2]][places],lty=1,col=1:length(places))

  #Running mean of.
  matplot(log$time,apply(log[,places],2,cumsum)/(1:n),type="l",
          lty=2,main="Running means",xlab="t",ylab="Running mean of no. of tokens")

  legend(3/4*max(log$time),maxTok,dimnames(log)[[2]][places],lty=1,col=1:length(places))

  ##Mean number of tokens.
  tokentab <- apply(log[,places],2,mean)
  ##Mean number of firings.
  transtab <- table(log$trans)/length(log$trans)
  names(transtab) <- pn$trans$name

  #show summary?
  print("Mean no. of tokens of embedded chain")
  print(tokentab)
  print("Distribution of firings.")
  print(transtab)
  par(mfcol=c(2,1))
  barplot(tokentab,main="Mean number of tokens at place.")
  barplot(t(transtab),main="Empirical distribution of firing transition")
  par(mfcol=c(1,1))

  
  if (stationary) {
    #Estimate transition rate matrix
    Lambda.pn <- ctmc.estimate.trm(log$time,M)
    #Based on this find approximate (all states are not observed)
    #stationary distribution.
    pi.pn   <- ctmc.stationary(Lambda.pn)
    #Show results.
    #print(Lambda.pn)
    print("Stationary distribution:")
    print(pi.pn)
    barplot(pi.pn,type="h",cex.names=0.6,las=2)
  } else {
    pi.pn <- NULL
    Lambda.pn <- NULL
  }

  invisible(list(log=log,pi=pi.pn,Lambda=Lambda.pn))
}


###################################################
### chunk number 9: 
###################################################
##Initial loading
require(XML)    
require(msm)


